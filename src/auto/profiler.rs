// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ffi;
use glib::translate::*;

glib::wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Profiler(Boxed<ffi::GjsProfiler>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gjs_profiler_get_type(), ptr as *mut _) as *mut ffi::GjsProfiler,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gjs_profiler_get_type(), ptr as *mut _),
        type_ => || ffi::gjs_profiler_get_type(),
    }
}

impl Profiler {
    #[doc(alias = "gjs_profiler_set_fd")]
    pub fn set_fd(&mut self, fd: i32) {
        unsafe {
            ffi::gjs_profiler_set_fd(self.to_glib_none_mut().0, fd);
        }
    }

    /// Set the file to which profiling data is written when the `self` is stopped.
    /// By default, this is `gjs-$PID.syscap` in the current directory.
    /// ## `filename`
    /// string containing a filename
    #[doc(alias = "gjs_profiler_set_filename")]
    pub fn set_filename(&mut self, filename: &str) {
        unsafe {
            ffi::gjs_profiler_set_filename(self.to_glib_none_mut().0, filename.to_glib_none().0);
        }
    }

    /// As expected, this starts the GjsProfiler.
    ///
    /// This will enable the underlying JS profiler and register a POSIX timer to
    /// deliver SIGPROF on the configured sampling frequency.
    ///
    /// To reduce sampling overhead, [`Profiler`][crate::Profiler] stashes information about the
    /// profile to be calculated once the profiler has been disabled. Calling
    /// [`stop()`][Self::stop()] will result in that delayed work to be completed.
    ///
    /// You should call [`stop()`][Self::stop()] when the profiler is no longer needed.
    #[doc(alias = "gjs_profiler_start")]
    pub fn start(&mut self) {
        unsafe {
            ffi::gjs_profiler_start(self.to_glib_none_mut().0);
        }
    }

    /// Stops a currently running [`Profiler`][crate::Profiler]. If the profiler is not running,
    /// this function will do nothing.
    ///
    /// Some work may be delayed until the end of the capture. Such delayed work
    /// includes flushing the resulting samples and file location information to
    /// disk.
    ///
    /// This may block while writing to disk. Generally, the writes are delivered
    /// to a tmpfs device, and are therefore negligible.
    #[doc(alias = "gjs_profiler_stop")]
    pub fn stop(&mut self) {
        unsafe {
            ffi::gjs_profiler_stop(self.to_glib_none_mut().0);
        }
    }
}
