// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi, Profiler};
use glib::{prelude::*, translate::*};

glib::wrapper! {
    ///
    ///
    /// ## Properties
    ///
    ///
    /// #### `exec-as-module`
    ///  Writeable | Construct Only
    ///
    ///
    /// #### `profiler-enabled`
    ///  Set this property to profile any JS code run by this context. By
    /// default, the profiler is started and stopped when you call
    /// [`Context::eval()`][crate::Context::eval()].
    ///
    /// The value of this property is superseded by the GJS_ENABLE_PROFILER
    /// environment variable.
    ///
    /// You may only have one context with the profiler enabled at a time.
    ///
    /// Writeable | Construct Only
    ///
    ///
    /// #### `profiler-sigusr2`
    ///  Set this property to install a SIGUSR2 signal handler that starts and
    /// stops the profiler. This property also implies that
    /// [`profiler-enabled`][struct@crate::Context#profiler-enabled] is set.
    ///
    /// Writeable | Construct Only
    ///
    ///
    /// #### `program-name`
    ///  Readable | Writeable | Construct Only
    ///
    ///
    /// #### `program-path`
    ///  Readable | Writeable | Construct Only
    ///
    ///
    /// #### `search-path`
    ///  Writeable | Construct Only
    #[doc(alias = "GjsContext")]
    pub struct Context(Object<ffi::GjsContext, ffi::GjsContextClass>);

    match fn {
        type_ => || ffi::gjs_context_get_type(),
    }
}

impl Context {
    #[doc(alias = "gjs_context_new")]
    pub fn new() -> Context {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::gjs_context_new()) }
    }

    /// ## `search_path`
    /// Path where modules to import should reside
    #[doc(alias = "gjs_context_new_with_search_path")]
    #[doc(alias = "new_with_search_path")]
    pub fn with_search_path(search_path: &[&str]) -> Context {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gjs_context_new_with_search_path(
                search_path.to_glib_none().0,
            ))
        }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`Context`] objects.
    ///
    /// This method returns an instance of [`ContextBuilder`](crate::builders::ContextBuilder) which can be used to create [`Context`] objects.
    pub fn builder() -> ContextBuilder {
        ContextBuilder::new()
    }

    /// ## `array_values`
    /// Array values
    #[doc(alias = "gjs_context_define_string_array")]
    pub fn define_string_array(
        &self,
        array_name: &str,
        array_values: &[&str],
    ) -> Result<(), glib::Error> {
        let array_length = array_values.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_define_string_array(
                self.to_glib_none().0,
                array_name.to_glib_none().0,
                array_length,
                array_values.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    ///
    /// # Returns
    ///
    ///
    /// ## `exit_status_p`
    /// exit status
    #[doc(alias = "gjs_context_eval")]
    pub fn eval(&self, script: &str, filename: &str) -> Result<i32, glib::Error> {
        let script_len = script.len() as _;
        unsafe {
            let mut exit_status_p = std::mem::MaybeUninit::uninit();
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_eval(
                self.to_glib_none().0,
                script.to_glib_none().0,
                script_len,
                filename.to_glib_none().0,
                exit_status_p.as_mut_ptr(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(exit_status_p.assume_init())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    ///
    /// # Returns
    ///
    ///
    /// ## `exit_status_p`
    /// exit status
    #[doc(alias = "gjs_context_eval_file")]
    pub fn eval_file(&self, filename: &str) -> Result<i32, glib::Error> {
        unsafe {
            let mut exit_status_p = std::mem::MaybeUninit::uninit();
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_eval_file(
                self.to_glib_none().0,
                filename.to_glib_none().0,
                exit_status_p.as_mut_ptr(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(exit_status_p.assume_init())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    ///
    /// # Returns
    ///
    ///
    /// ## `exit_code`
    /// exit code
    #[doc(alias = "gjs_context_eval_module")]
    pub fn eval_module(&self, identifier: &str) -> Result<u8, glib::Error> {
        unsafe {
            let mut exit_code = std::mem::MaybeUninit::uninit();
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_eval_module(
                self.to_glib_none().0,
                identifier.to_glib_none().0,
                exit_code.as_mut_ptr(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(exit_code.assume_init())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    ///
    /// # Returns
    ///
    ///
    /// ## `exit_status_p`
    /// exit status
    #[doc(alias = "gjs_context_eval_module_file")]
    pub fn eval_module_file(&self, filename: &str) -> Result<u8, glib::Error> {
        unsafe {
            let mut exit_status_p = std::mem::MaybeUninit::uninit();
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_eval_module_file(
                self.to_glib_none().0,
                filename.to_glib_none().0,
                exit_status_p.as_mut_ptr(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(exit_status_p.assume_init())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Initiate a full GC; may or may not block until complete. This
    /// function just calls Spidermonkey JS_GC().
    #[doc(alias = "gjs_context_gc")]
    pub fn gc(&self) {
        unsafe {
            ffi::gjs_context_gc(self.to_glib_none().0);
        }
    }

    /// Returns the profiler's internal instance of [`Profiler`][crate::Profiler] for you to
    /// customize, or [`None`] if profiling is not enabled on this [`Context`][crate::Context].
    ///
    /// # Returns
    ///
    /// a [`Profiler`][crate::Profiler]
    #[doc(alias = "gjs_context_get_profiler")]
    #[doc(alias = "get_profiler")]
    pub fn profiler(&self) -> Option<Profiler> {
        unsafe { from_glib_none(ffi::gjs_context_get_profiler(self.to_glib_none().0)) }
    }

    #[doc(alias = "gjs_context_make_current")]
    pub fn make_current(&self) {
        unsafe {
            ffi::gjs_context_make_current(self.to_glib_none().0);
        }
    }

    /// Similar to the Spidermonkey JS_MaybeGC() call which
    /// heuristically looks at JS runtime memory usage and
    /// may initiate a garbage collection.
    ///
    /// This function always unconditionally invokes JS_MaybeGC(), but
    /// additionally looks at memory usage from the system `malloc()`
    /// when available, and if the delta has grown since the last run
    /// significantly, also initiates a full JavaScript garbage
    /// collection. The idea is that since GJS is a bridge between
    /// JavaScript and system libraries, and JS objects act as proxies
    /// for these system memory objects, GJS consumers need a way to
    /// hint to the runtime that it may be a good idea to try a
    /// collection.
    ///
    /// A good time to call this function is when your application
    /// transitions to an idle state.
    #[doc(alias = "gjs_context_maybe_gc")]
    pub fn maybe_gc(&self) {
        unsafe {
            ffi::gjs_context_maybe_gc(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gjs_context_print_stack_stderr")]
    pub fn print_stack_stderr(&self) {
        unsafe {
            ffi::gjs_context_print_stack_stderr(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gjs_context_register_module")]
    pub fn register_module(&self, identifier: &str, uri: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gjs_context_register_module(
                self.to_glib_none().0,
                identifier.to_glib_none().0,
                uri.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Runs `func` immediately, not asynchronously, after entering the JS context's
    /// main realm. After `func` completes, leaves the realm again.
    ///
    /// You only need this if you are using JSAPI calls from the SpiderMonkey API
    /// directly.
    /// ## `func`
    /// function to run
    #[doc(alias = "gjs_context_run_in_realm")]
    pub fn run_in_realm<P: FnMut(&Context)>(&self, func: P) {
        let func_data: P = func;
        unsafe extern "C" fn func_func<P: FnMut(&Context)>(
            arg0: *mut ffi::GjsContext,
            arg1: glib::ffi::gpointer,
        ) {
            let arg0 = from_glib_borrow(arg0);
            let callback = arg1 as *mut P;
            (*callback)(&arg0)
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: &P = &func_data;
        unsafe {
            ffi::gjs_context_run_in_realm(
                self.to_glib_none().0,
                func,
                super_callback0 as *const _ as *mut _,
            );
        }
    }

    /// ## `array_values`
    /// Array values
    #[doc(alias = "gjs_context_set_argv")]
    pub fn set_argv(&self, array_values: &[&str]) {
        let array_length = array_values.len() as _;
        unsafe {
            ffi::gjs_context_set_argv(
                self.to_glib_none().0,
                array_length,
                array_values.to_glib_none().0,
            );
        }
    }

    #[doc(alias = "gjs_context_setup_debugger_console")]
    pub fn setup_debugger_console(&self) {
        unsafe {
            ffi::gjs_context_setup_debugger_console(self.to_glib_none().0);
        }
    }

    #[doc(alias = "program-name")]
    pub fn program_name(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "program-name")
    }

    #[doc(alias = "program-path")]
    pub fn program_path(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "program-path")
    }

    /// Returns a newly-allocated list containing all known instances of [`Context`][crate::Context].
    /// This is useful for operating on the contexts from a process-global situation
    /// such as a debugger.
    ///
    /// # Returns
    ///
    /// Known [`Context`][crate::Context] instances
    #[doc(alias = "gjs_context_get_all")]
    #[doc(alias = "get_all")]
    pub fn all() -> Vec<Context> {
        assert_initialized_main_thread!();
        unsafe { FromGlibPtrContainer::from_glib_full(ffi::gjs_context_get_all()) }
    }

    #[doc(alias = "gjs_context_get_current")]
    #[doc(alias = "get_current")]
    pub fn current() -> Option<Context> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::gjs_context_get_current()) }
    }
}

impl Default for Context {
    fn default() -> Self {
        Self::new()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`Context`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct ContextBuilder {
    builder: glib::object::ObjectBuilder<'static, Context>,
}

impl ContextBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    pub fn exec_as_module(self, exec_as_module: bool) -> Self {
        Self {
            builder: self.builder.property("exec-as-module", exec_as_module),
        }
    }

    /// Set this property to profile any JS code run by this context. By
    /// default, the profiler is started and stopped when you call
    /// [`Context::eval()`][crate::Context::eval()].
    ///
    /// The value of this property is superseded by the GJS_ENABLE_PROFILER
    /// environment variable.
    ///
    /// You may only have one context with the profiler enabled at a time.
    pub fn profiler_enabled(self, profiler_enabled: bool) -> Self {
        Self {
            builder: self.builder.property("profiler-enabled", profiler_enabled),
        }
    }

    /// Set this property to install a SIGUSR2 signal handler that starts and
    /// stops the profiler. This property also implies that
    /// [`profiler-enabled`][struct@crate::Context#profiler-enabled] is set.
    pub fn profiler_sigusr2(self, profiler_sigusr2: bool) -> Self {
        Self {
            builder: self.builder.property("profiler-sigusr2", profiler_sigusr2),
        }
    }

    pub fn program_name(self, program_name: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("program-name", program_name.into()),
        }
    }

    pub fn program_path(self, program_path: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("program-path", program_path.into()),
        }
    }

    pub fn search_path(self, search_path: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self.builder.property("search-path", search_path.into()),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`Context`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Context {
        self.builder.build()
    }
}
