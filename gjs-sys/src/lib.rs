// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use gio_sys as gio;
use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, off_t, size_t, ssize_t, time_t, uintptr_t, FILE,
};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GjsError = c_int;
pub const GJS_ERROR_FAILED: GjsError = 0;
pub const GJS_ERROR_SYSTEM_EXIT: GjsError = 1;

pub type GjsJSError = c_int;
pub const GJS_JS_ERROR_ERROR: GjsJSError = 0;
pub const GJS_JS_ERROR_EVAL_ERROR: GjsJSError = 1;
pub const GJS_JS_ERROR_INTERNAL_ERROR: GjsJSError = 2;
pub const GJS_JS_ERROR_RANGE_ERROR: GjsJSError = 3;
pub const GJS_JS_ERROR_REFERENCE_ERROR: GjsJSError = 4;
pub const GJS_JS_ERROR_STOP_ITERATION: GjsJSError = 5;
pub const GJS_JS_ERROR_SYNTAX_ERROR: GjsJSError = 6;
pub const GJS_JS_ERROR_TYPE_ERROR: GjsJSError = 7;
pub const GJS_JS_ERROR_URI_ERROR: GjsJSError = 8;

// Callbacks
pub type GjsContextInRealmFunc = Option<unsafe extern "C" fn(*mut GjsContext, *mut c_void)>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GjsContextClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GjsContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GjsContextClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GjsCoverageClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GjsCoverageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GjsCoverageClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GjsProfiler {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GjsProfiler = _GjsProfiler;

// Classes
#[repr(C)]
pub struct GjsContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GjsContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GjsContext @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GjsCoverage {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GjsCoverage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GjsCoverage @ {self:p}")).finish()
    }
}

#[link(name = "gjs")]
extern "C" {

    //=========================================================================
    // GjsJSError
    //=========================================================================
    pub fn gjs_js_error_get_type() -> GType;
    pub fn gjs_js_error_quark() -> glib::GQuark;

    //=========================================================================
    // GjsProfiler
    //=========================================================================
    pub fn gjs_profiler_get_type() -> GType;
    pub fn gjs_profiler_set_capture_writer(self_: *mut GjsProfiler, capture: *mut c_void);
    pub fn gjs_profiler_set_fd(self_: *mut GjsProfiler, fd: c_int);
    pub fn gjs_profiler_set_filename(self_: *mut GjsProfiler, filename: *const c_char);
    pub fn gjs_profiler_start(self_: *mut GjsProfiler);
    pub fn gjs_profiler_stop(self_: *mut GjsProfiler);
    pub fn gjs_profiler_chain_signal(context: *mut GjsContext, info: *mut c_void) -> gboolean;

    //=========================================================================
    // GjsContext
    //=========================================================================
    pub fn gjs_context_get_type() -> GType;
    pub fn gjs_context_new() -> *mut GjsContext;
    pub fn gjs_context_new_with_search_path(search_path: *mut *mut c_char) -> *mut GjsContext;
    pub fn gjs_context_get_all() -> *mut glib::GList;
    pub fn gjs_context_get_current() -> *mut GjsContext;
    pub fn gjs_context_define_string_array(
        js_context: *mut GjsContext,
        array_name: *const c_char,
        array_length: ssize_t,
        array_values: *mut *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_eval(
        js_context: *mut GjsContext,
        script: *const c_char,
        script_len: ssize_t,
        filename: *const c_char,
        exit_status_p: *mut c_int,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_eval_file(
        js_context: *mut GjsContext,
        filename: *const c_char,
        exit_status_p: *mut c_int,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_eval_module(
        context: *mut GjsContext,
        identifier: *const c_char,
        exit_code: *mut u8,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_eval_module_file(
        js_context: *mut GjsContext,
        filename: *const c_char,
        exit_status_p: *mut u8,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_gc(context: *mut GjsContext);
    pub fn gjs_context_get_native_context(js_context: *mut GjsContext) -> *mut c_void;
    pub fn gjs_context_get_profiler(self_: *mut GjsContext) -> *mut GjsProfiler;
    pub fn gjs_context_make_current(js_context: *mut GjsContext);
    pub fn gjs_context_maybe_gc(context: *mut GjsContext);
    pub fn gjs_context_print_stack_stderr(js_context: *mut GjsContext);
    pub fn gjs_context_register_module(
        context: *mut GjsContext,
        identifier: *const c_char,
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gjs_context_run_in_realm(
        gjs: *mut GjsContext,
        func: GjsContextInRealmFunc,
        user_data: *mut c_void,
    );
    pub fn gjs_context_set_argv(
        js_context: *mut GjsContext,
        array_length: ssize_t,
        array_values: *mut *const c_char,
    );
    pub fn gjs_context_setup_debugger_console(gjs: *mut GjsContext);

    //=========================================================================
    // GjsCoverage
    //=========================================================================
    pub fn gjs_coverage_get_type() -> GType;
    pub fn gjs_coverage_new(
        prefixes: *const *const c_char,
        context: *mut GjsContext,
        output_dir: *mut gio::GFile,
    ) -> *mut GjsCoverage;
    #[cfg(feature = "v1_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_66")))]
    pub fn gjs_coverage_enable();
    pub fn gjs_coverage_write_statistics(self_: *mut GjsCoverage);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gjs_dumpstack();
    pub fn gjs_error_quark() -> glib::GQuark;
    pub fn gjs_get_js_version() -> *const c_char;
    pub fn gjs_memory_report(where_: *const c_char, die_if_leaks: gboolean);

}
